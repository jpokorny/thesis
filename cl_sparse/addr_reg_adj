#!/usr/bin/env python
"""/
Program that for two input files (presumably representing a linearized code)
tries to "adjust" (memory) addresses and register numbers in the first file
to fit those in the other.

It's intended to be used prior to comparing such two files (in case we expect
these files are isomorphic except for addresses and, optionally, register
numbers).

Currently, the algorithm tolerates a line displacement of OFFSET_LIMIT
(line X in the first file expected to correspond to line Y..Y+OFFSET_LIMIT
in the other, where initially X=Y), but probably not robust enough, though.

Note: still quite slow for input files 500 KiB+.
"""

# for `file=stderr' argument with older Python versions (2.6 probably minimum)
from __future__ import print_function

__author__ = "Jan Pokorny <pokorny_jan@seznam.cz>"

from sys import argv, stdout, stderr, exit
from os.path import exists, split
from os import stat, makedirs
import re


VERBOSITY_FILE_TO_PROCESS    = True
VERBOSITY_NOTES              = False
VERBOSITY_MATCHES_DIFFER_MAX = 10
VERBOSITY_SUBST_REDEF_MAX    = 10

# tolerated corresponding lines displacement between the two files
OFFSET_LIMIT = 3

#
# RE definitions
# Note: group names required to distinguish them in proceeding.
#

# address: hexadecimal number (of arbitrary length) prefixed with "0x"
#          but not with "$0x" (which denotes immediate value)
RE_ADDR_STR   = r"(?P<addr>(?<!\$)0x[0-9a-fA-F]+(?=\W))"
# register number: decimal number (of arbitrary length) prefixed with "%r"
RE_REGNUM_STR = r"(?P<regnum>%r[1-9][0-9]*(?=\W))"

def open_smarter(name, mode):
    # http://stackoverflow.com/questions/273192/
    d, base = split(name)
    if d is not "":
        try:
            stat(d)
        except:
            makedirs(d)
    return open(name, mode), base

def mobj_to_strgrp(matchobj):
    return (matchobj.lastgroup, matchobj.group(0))

# Note: using inputs as lists of items generated with function above.
def same_strgrp_lists(strgrp_list1, strgrp_list2):
    if len(strgrp_list1) != len(strgrp_list2):
        return False
    for g1, g2 in zip(strgrp_list1, strgrp_list2):
        if g1[0] != g2[0]:
            return False
    return True

def addr_reg_adj(adj_text, src_text, pattern, dest_file="-"):
    re_ptrn = re.compile(pattern)

    if dest_file == "-":
        fdst, base = stdout, dest_file
    else:
        fdst, base = open_smarter(dest_file, "w")
        if VERBOSITY_FILE_TO_PROCESS:
            print(dest_file)

    matches_dict = {}
    adj_lines = adj_text.split("\n"); adj_lnum = len(adj_lines)
    src_lines = src_text.split("\n"); src_lnum = len(src_lines)
    if adj_lnum != src_lnum:
        print("warning:\tnumber of lines differ between files (%d, %d)"
              % (adj_lnum, src_lnum), file=stderr)
    matches_differ_cnt = subst_redef_cnt = 0
    adj_cnt = src_cnt = 0
    while adj_cnt < adj_lnum and src_cnt < src_lnum:
        adj_matches = map(mobj_to_strgrp, re_ptrn.finditer(adj_lines[adj_cnt]))
        src_matches = map(mobj_to_strgrp, re_ptrn.finditer(src_lines[src_cnt]))
        offset_pos = 0
        while not same_strgrp_lists(adj_matches, src_matches):
            if offset_pos == OFFSET_LIMIT:
                if matches_differ_cnt < VERBOSITY_MATCHES_DIFFER_MAX:
                    print("warning: %s: matches (number/type) differ between"
                          " files (lines %d/%d..%d)"
                          % (base, adj_cnt, src_cnt - offset_pos, src_cnt),
                          file=stderr)
                    matches_differ_cnt+=1
                elif matches_differ_cnt == VERBOSITY_MATCHES_DIFFER_MAX:
                    print("warning: %s: too many matches differences,"
                          " giving up reporting them all" % base, file=stderr)
                    matches_differ_cnt+=1
                # restore
                src_cnt -= offset_pos
                break
            elif VERBOSITY_NOTES:
                print("note: %s: lines do not correspond with each other,"
                      " trying lines around (lines %d/%d)"
                      % (base, adj_cnt, src_cnt), file=stderr)
            while not same_strgrp_lists(adj_matches, src_matches) \
                  and offset_pos < OFFSET_LIMIT:
                src_cnt += 1
                if src_cnt == src_lnum:
                    offset_pos = OFFSET_LIMIT
                    break
                offset_pos += 1
                src_matches = map(mobj_to_strgrp,
                                  re_ptrn.finditer(src_lines[src_cnt]))

        if offset_pos < OFFSET_LIMIT:
            # success with searching corresponding line in src file,
            # remember the substitutions in summary dict
            for adj_match, src_match in zip(adj_matches, src_matches):
                if adj_match[1] == src_match[1]:
                    continue
                adj_ptrn_re = re.compile("(?<!\$)" + adj_match[1] + "(?=\W)")
                old_src_ptrn = matches_dict.get(adj_ptrn_re, None)
                matches_dict[adj_ptrn_re] = src_match[1]
                if subst_redef_cnt < VERBOSITY_SUBST_REDEF_MAX \
                   and old_src_ptrn is not None and old_src_ptrn != src_match[1]:
                    print("warning: %s: redefining already defined substitution"
                          " (`%s\' -> `%s\', was `%s\')"
                          % (base, adj_ptrn_re.pattern, src_match[1],
                             old_src_ptrn), file=stderr)
                    subst_redef_cnt+=1
                elif subst_redef_cnt == VERBOSITY_SUBST_REDEF_MAX:
                    print("warning: %s: too many substitution redefinitions,"
                          " giving up reporting them all" % base, file=stderr)
                    subst_redef_cnt+=1
        adj_cnt += 1
        src_cnt += 1
    #while

    # do planned substitutions
    for adj_ptrn_re, src_ptrn in matches_dict.iteritems():
        adj_text = re.sub(adj_ptrn_re, src_ptrn, adj_text)

    fdst.write(adj_text)
    if (dest_file != "-"):
        fdst.close()
    return 0

if __name__ == "__main__":
    if len(argv) >= 3:
        pattern = RE_ADDR_STR
        if len(argv) >= 4 and argv[1] == "-r":
            pattern += "|" + RE_REGNUM_STR
            argv = argv[1:]
        if exists(argv[1]) and exists(argv[2]):
            dest_file = "-"
            f = open(argv[1], "r"); adj_text = f.read(); f.close()
            f = open(argv[2], "r"); src_text = f.read(); f.close()
            if len(argv) >= 4:
                dest_file = argv[3]
            ret = addr_reg_adj(adj_text, src_text, pattern, dest_file)
            exit(ret)
        else:
            print("error: cannot read input file(s)", file=stderr)
            exit(1)
    else:
        print("Usage: %s [-r] adj_file src_file [dest_file]" % argv[0])
        exit(2)
