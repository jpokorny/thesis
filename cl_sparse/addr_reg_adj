#!/usr/bin/env python
"""/
Program that for two input files (presumably representing a linearized code)
tries to "adjust" (memory) addresses and register numbers in the first file
to fit those in the other.

It's intended to be used prior to comparing such two files (in case we expect
these files are isomorphic except for addresses and, optionally, register
numbers).

Definitions:
- address
    hexadecimal number (of arbitrary length) prefixed with "0x"
    but not with "$0x" (which denotes immediate value)
- register number
    decimal number (of arbitrary length) prefixed with "%r"

Currently, the algorithm does not tolerate any line displacement (line X
in the first file expected to correspond to line X in the other).
"""

__author__ = "Jan Pokorny <pokorny_jan@seznam.cz>"

from sys import argv, stdout, exit
from os.path import exists
import re

re_address_str = r"(?<!\$)0x[0-9a-fA-F]+(?=\W)"
re_reg_num_str = r"%r[1-9][0-9]*(?=\W)"

def addr_reg_adj(adj_text, src_text, dest_file="-", use_reg=False):
    re_address = re.compile(re_address_str)
    re_reg_num = re.compile(re_reg_num_str)

    if dest_file == "-":
        fdst = stdout
    else:
        fdst = open(dest_file, "w")

    matches_dict = {}
    for i, (adj_line, src_line) in enumerate(zip(adj_text.split("\n"),
                                                 src_text.split("\n"))):
        adj_matches = re_address.findall(adj_line)
        src_matches = re_address.findall(src_line)
        if len(adj_matches) != len(src_matches):
            print("Warning: matches number does not fit between files"
                  " (same line %d)" % i)
        matches = zip(adj_matches, src_matches)

        if use_reg:
            adj_matches = re_reg_num.findall(adj_line)
            src_matches = re_reg_num.findall(src_line)
            if len(adj_matches) != len(src_matches):
                print("Warning: matches number does not fit between files"
                      " (same line %d)" % i)
            matches += zip(adj_matches, src_matches)

        # reflect the changes in summary dict
        for adj_ptrn, src_ptrn in matches:
            adj_ptrn_re = re.compile("(?<!\$)" + adj_ptrn + "(?=\W)")
            old_src_ptrn = matches_dict.get(adj_ptrn_re, None)
            matches_dict[adj_ptrn_re] = src_ptrn
            if old_src_ptrn is not None and old_src_ptrn != src_ptrn:
                print("Warning: redefining already defined substitution"
                      " (`%s\' -> `%s\', was `%s\')" % (adj_ptrn_re.pattern,
                                                        src_ptrn,
                                                        old_src_ptrn))

    for adj_ptrn_re, src_ptrn in matches_dict.iteritems():
        adj_text = re.sub(adj_ptrn_re, src_ptrn, adj_text)

    fdst.write(adj_text)
    if (dest_file != "-"):
        fdst.close()

if __name__ == "__main__":
    if len(argv) >= 3:
        use_reg = False
        if len(argv) >= 4 and argv[1] == "-r":
            use_reg = True
            argv = argv[1:]
        if exists(argv[1]) and exists(argv[2]):
            dest_file = "-"
            # XXX: tests, e.g. whether it is the same file
            f = open(argv[1], "r"); adj_text = f.read(); f.close()
            f = open(argv[2], "r"); src_text = f.read(); f.close()
            if len(argv) >= 4:
                dest_file = argv[3]
            ret = addr_reg_adj(adj_text, src_text, dest_file, use_reg)
            exit(ret)
        else:
            exit(1)
    else:
        print("Usage: %(script)s [-r] adj_file src_file [dest_file]"
              % {"script": argv[0]})
        exit(2)
